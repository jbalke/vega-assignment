---
alwaysApply: true
---

You are a coding assistant working inside Cursor with the following strict version control rules.

1. Semantic / Conventional Commits Only


When you propose or generate a commit message, you must use Conventional Commits style:


- feat: — new user-facing features

- fix: — bug fixes

- refactor: — internal refactors, no behavior change

- chore: — tooling, configs, dependency updates, build scripts

- docs: — documentation only

- test: — tests only (no production code changes)

- style: — formatting / style only, no behavior change

- perf: — performance improvements

You may use an optional scope in parentheses:


- feat(auth): add jwt-based login

- fix(cart): handle empty cart on checkout

Format:


- 
Summary line:

type(scope?): short, imperative summary

Examples:


	- feat(ui): add dark mode toggle

	- fix(api): handle null user id in profile endpoint

	- chore(ci): add github actions workflow


- 
Optional body:


	- Explain what and why, not how.

	- Use BREAKING CHANGE: in the body if you introduce a breaking change.


2. Every Commit Must Be a Working Build


You must treat every commit as a shippable unit:


- The project builds successfully.

- All existing tests pass.

- Any new or modified tests pass.

- Linting and formatting pass according to the project’s tools (e.g., ESLint, Prettier).

If your changes would break build/tests/lint, include the necessary fixes in the same commit.

Do not propose or describe commits that leave the codebase in a broken state.

When you describe a commit, assume the developer will only commit once your changes produce a passing build and clean lint.

3. Atomic, Coherent Commits


Each commit should be a single logical unit of work:


- Good examples:
	- feat(auth): implement password reset flow

	- fix(validation): prevent invalid email crash

	- chore(eslint): enable no-unused-vars and fix violations


- Avoid:
	- Mixing unrelated refactors and features in one commit

	- Combining big formatting changes with substantial logic changes


If multiple unrelated changes are needed, guide the user to separate them into multiple commits.

4. No WIP / Temporary / Debug Commits


Do not propose or generate commits that:


- Use messages like wip, temp, debug, misc changes, update.

- Contain stray debug statements, commented-out dead code, or experimental code that isn’t part of the final solution.

Code you produce should be in a state that is appropriate to commit directly under the given rules.

5. Test and Lint Responsibility


When you modify behavior or add features:


- Update or add tests in the same commit to cover the change.

- If you introduce new lint rules or stricter configs, fix resulting warnings/errors in the same commit.

If you can’t actually run tests or lint, you must still:


- Write code that is idiomatic and likely to pass the existing tooling.

- Explicitly state what tests or commands the user should run (e.g., npm test, pnpm lint) to validate the commit before pushing.

6. How to Present Commits in Responses


When asked to change code, structure your answer like this:


1. Summary of the change

2. Code edits (diffs or file blocks)

3. Suggested commit message in Conventional Commit format

4. Commands to validate (build, test, lint) before committing

Example:


- 
Commit message:

feat(auth): add jwt-based login endpoint



- 
Then show the relevant code changes and end with something like:


	- Run: npm run build

	- Run: npm test

	- Run: npm run lint


Confirm that all pass before creating the commit with the above message.